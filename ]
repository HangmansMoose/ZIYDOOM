const std = @import("std");
const readVarInt = std.mem.readVarInt;
const WADLoader = @import("wadloader.zig");
const Datatypes = @import("datatypes.zig");
const WADHeader = Datatypes.WADHeader;
const WADDirectory = Datatypes.WADDirectory;
// Using a struct in this way without any member variables
// is the same as a namespace in C++
pub const WADReader =  struct {
    //    My Original code. Using @memcpy means that you must know all values at comptime, which cant be done here 
    //    This includes the string concatenation

   //pub fn ReadHeaderData(ptr_wad_data: *const []u8, offset: i32, header: *WADHeader) !void
   // {
   //     //  parse wad
   //     // NOTE: relatively sure that the upper bounds of the slice is non-inclusive.
   //     @memcpy(header.*.wad_ident, ptr_wad_data[offset..(offset + 4)] ++ "\\0");
   //     @memcpy(header.*.directory_count, ptr_wad_data [(offset + 4)..(offset + 8)]);
   //     @memcpy(header.*.directory_offset, ptr_wad_data[(offset + 8)..(offset + 12)]);
   //     
   //    // Ensure the slice has enough data
   // }
   // 
   // pub fn ReadDirectoryData(ptr_wad_data: *const []u8, offset: i32, directory: *WADDirectory) !void 
   // {
   //    @memcpy(directory.*.lump_offset, ptr_wad_data[offset..(offset + 4)]);
   //    @memcpy(directory.*.lump_size, ptr_wad_data[(offset + 4)..(offset + 8)]);
   //    @memcpy(directory.*.lump_name, ptr_wad_data[(offset + 8)..(offset + 16)] ++ "\\0");

   // }

    // Corrected code 
    pub fn ReadHeaderData(wad_data: *const []u8, offset: i32, header: *WADHeader) !void {
        // Ensure the slice has enough data
        if (offset < 0 or offset + 12 > wad_data.*.len) {
            return error.InvalidOffset;
        }

        // Copy wad_ident (4 bytes)
        var gpa = std.heap.GeneralPurposeAllocator(.{}){};
        const allocator = gpa.allocator();

        const ident_store: [4]u8 = allocator.alloc(u8, 4);
        
        @memcpy(&ident_store, wad_data.*[@intCast(offset)..@intCast(offset + 4)]);
        for (ident_store, 0..) |char, i| {
            header.*.wad_ident[i] = char;
        }

        // Read directory_count (i32, 4 bytes)
        // First need to convert the slice to an i32, endianess is required here.
        
        const dir_count = readVarInt(i32, wad_data.*[@intCast(offset + 4)..@intCast(offset + 8)], std.builtin.Endian.little);
        header.directory_count = dir_count;

        // Read directory_offset (i32, 4 bytes)
        const dir_offset = readVarInt(i32, wad_data.*[@intCast(offset + 8)..@intCast(offset + 12)], std.builtin.Endian.little);
        header.directory_offset = dir_offset;
    }

    pub fn ReadDirectoryData(wad_data: *const []u8, offset: i32, directory: *WADDirectory) !void {
        // Ensure the slice has enough data
        if (offset < 0 or offset + 16 > wad_data.*.len) {
            return error.InvalidOffset;
        }

        // Read lump_offset (i32, 4 bytes)
        const converted_lump_offset = readVarInt(i32, wad_data.*[@intCast(offset)..@intCast(offset + 4)], 
                                              std.builtin.Endian.little);
        directory.lump_offset = converted_lump_offset;

        // Read lump_size (i32, 4 bytes)

        const converted_lump_size = readVarInt(i32, wad_data.*[@intCast(offset + 4)..@intCast(offset + 8)], 
                                            std.builtin.Endian.little);
        directory.lump_size = converted_lump_size;

        // Copy lump_name (8 bytes)
        @memcpy(&directory.lump_name, wad_data.*[@intCast(offset + 8)..@intCast(offset + 16)]);
    }
};

